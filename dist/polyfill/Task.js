var o=["user-blocking","user-visible","background"];var x=0;function E(){return x++}var b=class{channel=new MessageChannel;sendPort=this.channel.port2;callbackByMessageId={};constructor(){this.channel.port1.onmessage=e=>this.onMessageReceived(e)}queueCallback(e){let t=E();return this.callbackByMessageId[t]=e,this.sendPort.postMessage(t),t}cancelCallback(e){delete this.callbackByMessageId[e]}onMessageReceived(e){let t=e.data,r=this.callbackByMessageId[t];r&&(delete this.callbackByMessageId[t],r())}},k;try{k=new b}catch(s){console.error(s)}var a=class{callback;callbackType=2;handle=null;canceled=!1;constructor(e,t,r=0){this.callback=e,this.schedule(t,r)}isIdleCallback(){return this.callbackType===0}isMessageChannelCallback(){return this.callbackType===2}cancel(){if(!this.canceled)switch(this.canceled=!0,this.callbackType){case 0:this.handle&&cancelIdleCallback(this.handle);break;case 1:this.handle&&clearTimeout(this.handle);break;case 2:this.handle&&k.cancelCallback(this.handle);break;default:throw new TypeError("Unknown CallbackType")}}schedule(e,t){if(t&&t>0){this.callbackType=1,this.handle=setTimeout(()=>{this.runCallback()},t);return}if(!o.includes(e))throw new TypeError(`Invalid task priority : ${e}`);if(e==="background"&&typeof requestIdleCallback=="function"){this.callbackType=0,this.handle=requestIdleCallback(()=>{this.runCallback()});return}if(typeof MessageChannel=="function"){this.callbackType=2,this.handle=k.queueCallback(()=>{this.runCallback()});return}this.callbackType=1,this.handle=setTimeout(()=>{this.runCallback()})}runCallback(){this.canceled||this.callback()}};var I=0,c=class{headTask=null;tailTask=null;constructor(){}push(e){if(typeof e!="object")throw new TypeError("Task must be an object");e.sequenceId=I++,this.headTask?(e.prev=this.tailTask,this.tailTask&&(this.tailTask.next=e)):(e.prev=null,this.headTask=e),e.next=null,this.tailTask=e}takeNextTask(){if(!this.headTask)return null;let e=this.headTask;return this.remove(e),e}merge(e,t){if(typeof t!="function")throw new TypeError("Must provide a selector function.");if(e==null)throw new Error("sourceQueue cannot be null");let r=this.headTask,i=null,l=e.headTask;for(;l;){let n=l;if(l=l.next,t(n)){for(e.remove(n);r&&r.sequenceId<n.sequenceId;)i=r,r=r.next;this.insert(n,i),i=n}}}insert(e,t){if(t==this.tailTask){this.push(e);return}let r=t?t.next:this.headTask;e.next=r,r.prev=e,e.prev=t,t!=null?t.next=e:this.headTask=e}remove(e){e===this.headTask&&(this.headTask=e.next),e===this.tailTask&&(this.tailTask=this.tailTask.prev),e.next&&(e.next.prev=e.prev),e.prev&&(e.prev.next=e.next)}};var T=class{callback;options;resolve;reject;hostCallback=null;abortCallback=null;isContinuation;promise;id;get sequenceId(){if(!this.id)throw new Error("sequenceId has not been set!");return this.id}set sequenceId(e){this.id=e}prev=null;next=null;constructor(e,t,r=!1){this.callback=e,this.options=t,this.isContinuation=r,this.promise=new Promise((i,l)=>{this.resolve=i,this.reject=l})}onTaskCompleted(){!this.options.signal||!this.abortCallback||(this.options.signal.removeEventListener("abort",this.abortCallback),this.abortCallback=null)}onTaskAborted(){this.hostCallback&&(this.hostCallback.cancel(),this.hostCallback=null),this.options.signal.removeEventListener("abort",this.abortCallback),this.abortCallback=null,this.reject(this.options.signal.reason)}isAborted(){return this.options.signal&&this.options.signal.aborted}},d=class{queues={};pendingHostCallback=null;signals=new WeakMap;constructor(){for(let e of o)this.queues[e]=[new c,new c]}yield(){return this.postTaskOrContinuation(()=>{},{priority:"user-visible"},!0)}postTask(e,t){return this.postTaskOrContinuation(e,t,!1)}async postTaskOrContinuation(e,t,r=!1){if(t=Object.assign({},t),t.signal!==void 0){if(t.signal===null||!("aborted"in t.signal)||typeof t.signal.addEventListener!="function")throw new TypeError("'signal' is not a valid 'AbortSignal'");if(t.signal&&"priority"in t.signal&&!o.includes(t.signal.priority))throw new TypeError(`Invalid task priority: '${t.signal.priority}'`)}if(t.priority!==void 0&&(t.priority===null||!o.includes(t.priority)))throw new TypeError(`Invalid task priority: '${t.priority}'`);if(t.delay===void 0&&(t.delay=0),t.delay=Number(t.delay),t.delay<0)throw new TypeError("'delay' must be a positive number.");let i=new T(e,t,r);return this.schedule(i),await i.promise}schedule(e){let t=e.options.signal;if(t){if(t.aborted){e.reject(t.reason);return}e.abortCallback=()=>{e.onTaskAborted()},t.addEventListener("abort",e.abortCallback)}if(e.options.delay&&e.options.delay>0){e.hostCallback=new a(()=>{e.hostCallback=null,this.onTaskDelayExpired(e)},null,e.options.delay);return}this.pushTask(e),this.scheduleHostCallbackIfNeeded()}onTaskDelayExpired(e){this.pushTask(e),this.pendingHostCallback&&(this.pendingHostCallback.cancel(),this.pendingHostCallback=null),this.schedulerEntryCallback()}onPriorityChange(e){let t=this.signals.get(e);if(t===void 0)throw new Error("Attempting to change priority on an unregistered signal");if(t!==e.priority){for(let r=0;r<2;r++){let i=this.queues[t][r];this.queues[e.priority][r].merge(i,n=>n.options.signal===e)}this.signals.set(e,e.priority)}}schedulerEntryCallback(){this.pendingHostCallback=null,this.runNextTask(),this.scheduleHostCallbackIfNeeded()}scheduleHostCallbackIfNeeded(){let{priority:e}=this.nextTaskPriority();e!=null&&(e!=="background"&&this.pendingHostCallback&&this.pendingHostCallback.isIdleCallback()&&(this.pendingHostCallback.cancel(),this.pendingHostCallback=null),!this.pendingHostCallback&&(this.pendingHostCallback=new a(()=>{this.schedulerEntryCallback()},e,0)))}pushTask(e){let t;if(e.options.priority?t=e.options.priority:e.options.signal&&"priority"in e.options.signal?t=e.options.signal.priority:t="user-visible",!o.includes(t))throw new TypeError(`Invalid task priority: ${t}`);if(e.options.signal&&"priority"in e.options.signal){let r=e.options.signal;this.signals.has(r)||(r.addEventListener("prioritychange",()=>{this.onPriorityChange(r)}),this.signals.set(r,r.priority))}this.queues[t][e.isContinuation?0:1].push(e)}runNextTask(){let e=null;do{let{priority:t,type:r}=this.nextTaskPriority();if(t==null)return;e=this.queues[t][r].takeNextTask()}while(!e||e.isAborted());try{let t=e.callback();e.resolve(t)}catch(t){e.reject(t)}finally{e.onTaskCompleted()}}nextTaskPriority(){for(let e of o)for(let t=0;t<2;t++)if(this.queues[e][t].headTask)return{priority:e,type:t};return{priority:null,type:0}}};var h=class extends AbortSignal{_priority="user-visible";get priority(){return this._priority}_onprioritychange=null;set onprioritychange(e){this._onprioritychange&&this.removeEventListener("prioritychange",this._onprioritychange),this.addEventListener("prioritychange",e),this._onprioritychange=e}get onprioritychange(){return this._onprioritychange}},u=class extends Event{previousPriority;constructor(e,t){if(!t||!o.includes(t.previousPriority))throw new TypeError(`Invalid task priority: '${t.previousPriority}'`);super(e),this.previousPriority=t.previousPriority}},y=class extends AbortController{isPriorityChanging_=!1;signal;constructor(e){if(super(),e||(e={}),typeof e!="object")throw new TypeError("'init' is not an object");let t=e.priority?e.priority:"user-visible";if(!o.includes(t))throw new TypeError(`Invalid task priority: '${t}'`);this.signal=Object.setPrototypeOf(super.signal,h.prototype),Object.defineProperty(this.signal,"_priority",{configurable:!1,enumerable:!1,writable:!0,value:t})}setPriority(e){if(!o.includes(e))throw new TypeError("Invalid task priority: "+e);if(this.isPriorityChanging_)throw new DOMException("","NotAllowedError");if(this.signal.priority===e)return;this.isPriorityChanging_=!0;let t=this.signal.priority;Object.defineProperty(this.signal,"_priority",{configurable:!1,enumerable:!1,writable:!0,value:e});let r=new u("prioritychange",{previousPriority:t});this.signal.dispatchEvent(r),this.isPriorityChanging_=!1}};var H=()=>{};function w(){return globalThis.scheduler.postTask(H,{priority:"user-blocking"})}var p=class s extends Promise{static defaultControllerOptions={priority:"background"};static runWithController(e,t,...r){return new s((i,l)=>{try{let n=t(...r);i(n)}catch(n){l(n)}},e)}static runWithOptions(e,t,...r){return new s((i,l)=>{try{let n=t(...r);i(n)}catch(n){l(n)}},new TaskController(e))}static runWithPriority(e,t,...r){return new s((i,l)=>{try{let n=t(...r);i(n)}catch(n){l(n)}},new TaskController({priority:e}))}static run(e,...t){return new s((r,i)=>{try{let l=e(...t);r(l)}catch(l){i(l)}})}static wrapWithController(e,t){return new s((r,i)=>t.then(r,i),e)}static wrapWithOptions(e,t){return new s((r,i)=>t.then(r,i),new TaskController(e))}static wrapWithPriority(e,t){return new s((r,i)=>t.then(r,i),new TaskController({priority:e}))}static wrap(e){return new s((t,r)=>e.then(t,r))}static all(e){return s.wrap(Promise.all(e))}static allSettled(e){return s.wrap(Promise.allSettled(e))}static any(e){return s.wrap(Promise.any(e))}static withResolvers(){let e,t,r=new s((i,l)=>{e=i,t=l});return{task:r,promise:r,resolve:e,reject:t}}static try(e,...t){return s.wrap(Promise.try(e,...t))}static race(e){return s.wrap(Promise.race(e))}static reject(e){return s.wrap(Promise.reject(e))}static resolve(e){return s.wrap(Promise.resolve(e))}controller;get priority(){return this.controller.signal.priority}set priority(e){this.controller.setPriority(e)}setPriority(e){this.controller.setPriority(e)}constructor(e,t=new TaskController(s.defaultControllerOptions)){let r=new Proxy(e,{apply(i,l,[n,C]){let v=new Proxy(n,{apply(f,m,[g]){return scheduler.postTask(()=>f(g),t)}}),P=new Proxy(C,{apply(f,m,[g]){return scheduler.postTask(()=>f(g),t)}});return i(v,P)}});super(r),this.controller=t}then(e,t){return new s((r,i)=>super.then(l=>{r(e?e(l):l)},l=>{i(t?t(l):l)}),this.controller)}catch(e){return new s((t,r)=>super.catch(i=>{r(e?e(i):i)}),this.controller)}finally(e){return new s((t,r)=>super.finally(e).then(t,r),this.controller)}};typeof scheduler>"u"?(console.log("Polyfilling globalThis.scheduler ..."),globalThis.scheduler=new d,console.log("Polyfilling globalThis.TaskController ..."),globalThis.TaskController=y,console.log("Polyfilling globalThis.TaskSignal ..."),globalThis.TaskSignal=h,console.log("Polyfilling globalThis.TaskPriorityChangeEvent ..."),globalThis.TaskPriorityChangeEvent=u,console.log("Polyfill complete.")):scheduler.yield||(console.log("Polyfilling globalThis.scheduler.yield ..."),globalThis.scheduler.yield=w,console.log("Polyfill complete."));var R=p;export{p as Task,R as default};
