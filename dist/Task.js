var c=class s extends Promise{static defaultControllerOptions={priority:"background"};static runWithController(r,t,...e){return new s((n,o)=>{try{let i=t(...e);n(i)}catch(i){o(i)}},r)}static runWithOptions(r,t,...e){return new s((n,o)=>{try{let i=t(...e);n(i)}catch(i){o(i)}},new TaskController(r))}static runWithPriority(r,t,...e){return new s((n,o)=>{try{let i=t(...e);n(i)}catch(i){o(i)}},new TaskController({priority:r}))}static run(r,...t){return new s((e,n)=>{try{let o=r(...t);e(o)}catch(o){n(o)}})}static wrapWithController(r,t){return new s((e,n)=>t.then(e,n),r)}static wrapWithOptions(r,t){return new s((e,n)=>t.then(e,n),new TaskController(r))}static wrapWithPriority(r,t){return new s((e,n)=>t.then(e,n),new TaskController({priority:r}))}static wrap(r){return new s((t,e)=>r.then(t,e))}static all(r){return s.wrap(Promise.all(r))}static allSettled(r){return s.wrap(Promise.allSettled(r))}static any(r){return s.wrap(Promise.any(r))}static withResolvers(){let r,t,e=new s((n,o)=>{r=n,t=o});return{task:e,promise:e,resolve:r,reject:t}}static try(r,...t){return s.wrap(Promise.try(r,...t))}static race(r){return s.wrap(Promise.race(r))}static reject(r){return s.wrap(Promise.reject(r))}static resolve(r){return s.wrap(Promise.resolve(r))}controller;get priority(){return this.controller.signal.priority}set priority(r){this.controller.setPriority(r)}setPriority(r){this.controller.setPriority(r)}constructor(r,t=new TaskController(s.defaultControllerOptions)){let e=new Proxy(r,{apply(n,o,[i,u]){let p=new Proxy(i,{apply(l,w,[a]){return scheduler.postTask(()=>l(a),t)}}),h=new Proxy(u,{apply(l,w,[a]){return scheduler.postTask(()=>l(a),t)}});return n(p,h)}});super(e),this.controller=t}then(r,t){return new s((e,n)=>super.then(o=>{e(r?r(o):o)},o=>{n(t?t(o):o)}),this.controller)}catch(r){return new s((t,e)=>super.catch(n=>{e(r?r(n):n)}),this.controller)}finally(r){return new s((t,e)=>super.finally(r).then(t,e),this.controller)}},y=c;export{c as Task,y as default};
